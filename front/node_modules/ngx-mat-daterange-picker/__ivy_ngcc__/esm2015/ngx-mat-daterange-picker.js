import { Injectable, Inject, InjectionToken, Component, ViewEncapsulation, Injector, ViewChild, Output, EventEmitter, Input, ChangeDetectionStrategy, ChangeDetectorRef, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { animate, state, style, transition, trigger, group } from '@angular/animations';
import { OverlayRef, Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import { takeWhile } from 'rxjs/operators';
import { DatePipe, CommonModule } from '@angular/common';
import { MatCalendar, MatDatepickerModule } from '@angular/material/datepicker';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatNativeDateModule } from '@angular/material/core';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/overlay';
import * as ɵngcc2 from '@angular/material/button';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@angular/material/form-field';
import * as ɵngcc5 from '@angular/material/input';
import * as ɵngcc6 from '@angular/material/tooltip';
import * as ɵngcc7 from '@angular/material/datepicker';

const _c0 = ["calendarInput"];
function PresetsComponent_li_2_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 2);
    ɵngcc0.ɵɵlistener("click", function PresetsComponent_li_2_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const preset_r1 = ctx.$implicit; const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.setPresetPeriod(preset_r1); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const preset_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", preset_r1.presetLabel, " ");
} }
const DATE = new InjectionToken('date');
class RangeStoreService {
    /**
     * @param {?} _fromDate
     * @param {?} _toDate
     */
    constructor(_fromDate, _toDate) {
        this._fromDate = _fromDate;
        this._toDate = _toDate;
        this.rangeUpdate$ = new Subject();
    }
    /**
     * @return {?}
     */
    get fromDate() {
        return this._fromDate;
    }
    /**
     * @return {?}
     */
    get toDate() {
        return this._toDate;
    }
    /**
     * @param {?=} fromDate
     * @param {?=} toDate
     * @return {?}
     */
    updateRange(fromDate = this._fromDate, toDate = this._toDate) {
        this._fromDate = fromDate;
        this._toDate = toDate;
        this.rangeUpdate$.next({ fromDate: this._fromDate, toDate: this._toDate });
    }
}
RangeStoreService.ɵfac = function RangeStoreService_Factory(t) { return new (t || RangeStoreService)(ɵngcc0.ɵɵinject(DATE), ɵngcc0.ɵɵinject(DATE)); };
RangeStoreService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RangeStoreService, factory: RangeStoreService.ɵfac });
/** @nocollapse */
RangeStoreService.ctorParameters = () => [
    { type: Date, decorators: [{ type: Inject, args: [DATE,] }] },
    { type: Date, decorators: [{ type: Inject, args: [DATE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RangeStoreService, [{
        type: Injectable
    }], function () { return [{ type: Date, decorators: [{
                type: Inject,
                args: [DATE]
            }] }, { type: Date, decorators: [{
                type: Inject,
                args: [DATE]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ConfigStoreService {
    constructor() {
        this.defaultOptions = {
            excludeWeekends: false,
            animation: true,
            locale: 'en-US',
            fromMinMax: { fromDate: null, toDate: null },
            toMinMax: { fromDate: null, toDate: null }
        };
    }
    /**
     * @return {?}
     */
    get ngxDrpOptions() {
        return this._ngxDrpOptions;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set ngxDrpOptions(options) {
        this._ngxDrpOptions = Object.assign({}, this.defaultOptions, options);
    }
}
ConfigStoreService.ɵfac = function ConfigStoreService_Factory(t) { return new (t || ConfigStoreService)(); };
ConfigStoreService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ConfigStoreService, factory: ConfigStoreService.ɵfac });
/** @nocollapse */
ConfigStoreService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfigStoreService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const pickerOverlayAnimations = {
    /** Transforms the height of the picker overlay content. */
    transformPanel: trigger('transformPickerOverlay', [
        state('void', style({ opacity: 0, transform: 'scale(1, 0)' })),
        state('enter', style({ opacity: 1, transform: 'scale(1, 1)' })),
        transition('void => enter', group([
            animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')
        ])),
        transition('* => void', animate('100ms linear', style({ opacity: 0 })))
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PickerOverlayComponent {
    /**
     * @param {?} rangeStoreService
     * @param {?} configStoreService
     * @param {?} overlayRef
     */
    constructor(rangeStoreService, configStoreService, overlayRef) {
        this.rangeStoreService = rangeStoreService;
        this.configStoreService = configStoreService;
        this.overlayRef = overlayRef;
        this.presets = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.fromDate = this.rangeStoreService.fromDate;
        this.toDate = this.rangeStoreService.toDate;
        this.startDatePrefix = this.configStoreService.ngxDrpOptions.startDatePrefix || 'FROM:';
        this.endDatePrefix = this.configStoreService.ngxDrpOptions.endDatePrefix || 'TO:';
        this.applyLabel = this.configStoreService.ngxDrpOptions.applyLabel || 'Apply';
        this.cancelLabel = this.configStoreService.ngxDrpOptions.cancelLabel || 'Cancel';
        this.presets = this.configStoreService.ngxDrpOptions.presets;
        this.shouldAnimate = this.configStoreService.ngxDrpOptions.animation
            ? 'enter'
            : 'noop';
        ({
            fromDate: this.fromMinDate,
            toDate: this.fromMaxDate
        } = this.configStoreService.ngxDrpOptions.fromMinMax);
        ({
            fromDate: this.toMinDate,
            toDate: this.toMaxDate
        } = this.configStoreService.ngxDrpOptions.toMinMax);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    updateFromDate(date) {
        this.fromDate = date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    updateToDate(date) {
        this.toDate = date;
    }
    /**
     * @param {?} presetItem
     * @return {?}
     */
    updateRangeByPreset(presetItem) {
        this.updateFromDate(presetItem.range.fromDate);
        this.updateToDate(presetItem.range.toDate);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    applyNewDates(e) {
        this.rangeStoreService.updateRange(this.fromDate, this.toDate);
        this.disposeOverLay();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    discardNewDates(e) {
        // this.rangeStoreService.updateRange();
        this.disposeOverLay();
    }
    /**
     * @return {?}
     */
    disposeOverLay() {
        this.overlayRef.dispose();
    }
}
PickerOverlayComponent.ɵfac = function PickerOverlayComponent_Factory(t) { return new (t || PickerOverlayComponent)(ɵngcc0.ɵɵdirectiveInject(RangeStoreService), ɵngcc0.ɵɵdirectiveInject(ConfigStoreService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.OverlayRef)); };
PickerOverlayComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PickerOverlayComponent, selectors: [["ngx-mat-drp-picker-overlay"]], decls: 13, vars: 12, consts: [[1, "ngx-mat-drp-calendar-container"], [1, "ngx-mat-drp-calendar-item"], [3, "prefixLabel", "selectedDate", "minDate", "maxDate", "selectedDateChange"], [1, "ngx-mat-drp-menu"], [3, "presets", "presetChanged"], [1, "ngx-mat-drp-controls"], ["mat-button", "", "color", "primary", 3, "click"], ["mat-button", "", 3, "click"]], template: function PickerOverlayComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "calendar-wrapper", 2);
        ɵngcc0.ɵɵlistener("selectedDateChange", function PickerOverlayComponent_Template_calendar_wrapper_selectedDateChange_2_listener($event) { return ctx.updateFromDate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 1);
        ɵngcc0.ɵɵelementStart(4, "calendar-wrapper", 2);
        ɵngcc0.ɵɵlistener("selectedDateChange", function PickerOverlayComponent_Template_calendar_wrapper_selectedDateChange_4_listener($event) { return ctx.updateToDate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 1);
        ɵngcc0.ɵɵelementStart(6, "div", 3);
        ɵngcc0.ɵɵelementStart(7, "mat-drp-presets", 4);
        ɵngcc0.ɵɵlistener("presetChanged", function PickerOverlayComponent_Template_mat_drp_presets_presetChanged_7_listener($event) { return ctx.updateRangeByPreset($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "button", 6);
        ɵngcc0.ɵɵlistener("click", function PickerOverlayComponent_Template_button_click_9_listener($event) { return ctx.applyNewDates($event); });
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "button", 7);
        ɵngcc0.ɵɵlistener("click", function PickerOverlayComponent_Template_button_click_11_listener($event) { return ctx.discardNewDates($event); });
        ɵngcc0.ɵɵtext(12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@transformPickerOverlay", ctx.shouldAnimate);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("prefixLabel", ctx.startDatePrefix)("selectedDate", ctx.fromDate)("minDate", ctx.fromMinDate)("maxDate", ctx.fromMaxDate);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("prefixLabel", ctx.endDatePrefix)("selectedDate", ctx.toDate)("minDate", ctx.toMinDate)("maxDate", ctx.toMaxDate);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("presets", ctx.presets);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.applyLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.cancelLabel);
    } }, directives: function () { return [CalendarWrapperComponent, PresetsComponent, ɵngcc2.MatButton]; }, styles: [".ngx-mat-drp-calendar-container{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;min-width:650px;height:300px}.ngx-mat-drp-calendar-item{-ms-flex-preferred-size:33.33%;flex-basis:33.33%;min-width:210px;padding:1em;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px;font-weight:400}.ngx-mat-drp-menu{height:100%}.ngx-mat-drp-controls{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;margin:10% auto}.ngx-mat-drp-overlay{-webkit-box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);background:#fff;border-radius:2px}.ngx-mat-drp-overlay-backdrop{background-color:rgba(0,0,0,.2);opacity:.2}"], encapsulation: 2, data: { animation: [pickerOverlayAnimations.transformPanel] } });
/** @nocollapse */
PickerOverlayComponent.ctorParameters = () => [
    { type: RangeStoreService },
    { type: ConfigStoreService },
    { type: OverlayRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PickerOverlayComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-mat-drp-picker-overlay',
                template: `<div [@transformPickerOverlay]="shouldAnimate" class="ngx-mat-drp-calendar-container">

  <div class="ngx-mat-drp-calendar-item">
    <calendar-wrapper 
    [prefixLabel]="startDatePrefix"
    [selectedDate]="fromDate"
    [minDate]="fromMinDate"
    [maxDate]="fromMaxDate"
    (selectedDateChange)="updateFromDate($event)">
  </calendar-wrapper>
  </div>
  <div class="ngx-mat-drp-calendar-item">
    <calendar-wrapper 
    [prefixLabel]="endDatePrefix"
    [selectedDate]="toDate"
    [minDate]="toMinDate"
    [maxDate]="toMaxDate" 
    (selectedDateChange)="updateToDate($event)">
  </calendar-wrapper>
  </div>
  <div class="ngx-mat-drp-calendar-item">
    <div class="ngx-mat-drp-menu">
      <mat-drp-presets [presets]="presets" (presetChanged)="updateRangeByPreset($event)"></mat-drp-presets>
      <div class="ngx-mat-drp-controls">
        <button mat-button color="primary" (click)="applyNewDates($event)">{{applyLabel}}</button>
        <button mat-button (click)="discardNewDates($event)">{{cancelLabel}}</button>
      </div>
    </div>
  </div>
</div>
`,
                styles: [`.ngx-mat-drp-calendar-container{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;min-width:650px;height:300px}.ngx-mat-drp-calendar-item{-ms-flex-preferred-size:33.33%;flex-basis:33.33%;min-width:210px;padding:1em;font-family:Roboto,"Helvetica Neue",sans-serif;font-size:14px;font-weight:400}.ngx-mat-drp-menu{height:100%}.ngx-mat-drp-controls{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;margin:10% auto}.ngx-mat-drp-overlay{-webkit-box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);background:#fff;border-radius:2px}.ngx-mat-drp-overlay-backdrop{background-color:rgba(0,0,0,.2);opacity:.2}`],
                animations: [pickerOverlayAnimations.transformPanel],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: RangeStoreService }, { type: ConfigStoreService }, { type: ɵngcc1.OverlayRef }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_CONFIG = {
    panelClass: 'ngx-mat-drp-overlay',
    hasBackdrop: true,
    backdropClass: 'ngx-mat-drp-overlay-backdrop',
    shouldCloseOnBackdropClick: true
};
class CalendarOverlayService {
    /**
     * @param {?} overlay
     * @param {?} injector
     */
    constructor(overlay, injector) {
        this.overlay = overlay;
        this.injector = injector;
    }
    /**
     * @param {?=} config
     * @param {?=} hostElemRef
     * @return {?}
     */
    open(config = {}, hostElemRef) {
        this.hostElemRef = hostElemRef;
        /** @type {?} */
        const overlayConfig = Object.assign({}, DEFAULT_CONFIG, config);
        /** @type {?} */
        const overlayRef = this.createOverlay(overlayConfig);
        /** @type {?} */
        const portalInjector = this.createInjector(overlayRef);
        /** @type {?} */
        const calendarPortal = new ComponentPortal(PickerOverlayComponent, null, portalInjector);
        overlayRef.attach(calendarPortal);
        overlayRef
            .backdropClick()
            .pipe(takeWhile(() => overlayConfig.shouldCloseOnBackdropClick))
            .subscribe(() => overlayRef.dispose());
        return overlayRef;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    createOverlay(config) {
        /** @type {?} */
        const overlayConfig = this.getOverlayConfig(config);
        return this.overlay.create(overlayConfig);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getOverlayConfig(config) {
        /** @type {?} */
        const positionStrategy = this.overlay
            .position()
            .flexibleConnectedTo(this.hostElemRef)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withDefaultOffsetY(12)
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
        /** @type {?} */
        const overlayConfig = new OverlayConfig({
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.panelClass,
            scrollStrategy: this.overlay.scrollStrategies.block(),
            positionStrategy
        });
        return overlayConfig;
    }
    /**
     * @param {?} overlayRef
     * @return {?}
     */
    createInjector(overlayRef) {
        /** @type {?} */
        const injectionTokens = new WeakMap();
        injectionTokens.set(OverlayRef, overlayRef);
        return new PortalInjector(this.injector, injectionTokens);
    }
}
CalendarOverlayService.ɵfac = function CalendarOverlayService_Factory(t) { return new (t || CalendarOverlayService)(ɵngcc0.ɵɵinject(ɵngcc1.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
CalendarOverlayService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CalendarOverlayService, factory: CalendarOverlayService.ɵfac });
/** @nocollapse */
CalendarOverlayService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarOverlayService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Overlay }, { type: ɵngcc0.Injector }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxMatDrpComponent {
    /**
     * @param {?} changeDetectionRef
     * @param {?} calendarOverlayService
     * @param {?} rangeStoreService
     * @param {?} configStoreService
     * @param {?} datePipe
     */
    constructor(changeDetectionRef, calendarOverlayService, rangeStoreService, configStoreService, datePipe) {
        this.changeDetectionRef = changeDetectionRef;
        this.calendarOverlayService = calendarOverlayService;
        this.rangeStoreService = rangeStoreService;
        this.configStoreService = configStoreService;
        this.datePipe = datePipe;
        this.selectedDateRangeChanged = new EventEmitter();
        this.selectedDateRange = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.configStoreService.ngxDrpOptions = this.options;
        this.options.placeholder = this.options.placeholder || 'Choose a date';
        this.rangeUpdate$ = this.rangeStoreService.rangeUpdate$.subscribe(range => {
            /** @type {?} */
            const from = this.formatToDateString(range.fromDate, this.options.format);
            /** @type {?} */
            const to = this.formatToDateString(range.toDate, this.options.format);
            this.selectedDateRange = `${from} - ${to}`;
            this.selectedDateRangeChanged.emit(range);
        });
        this.rangeStoreService.updateRange(this.options.range.fromDate, this.options.range.toDate);
        this.changeDetectionRef.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.rangeUpdate$) {
            this.rangeUpdate$.unsubscribe();
        }
    }
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    formatToDateString(date, format) {
        return this.datePipe.transform(date, format);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openCalendar(event) {
        /** @type {?} */
        const overlayRef = this.calendarOverlayService.open(this.options.calendarOverlayConfig, this.calendarInput);
    }
    /**
     * @param {?} range
     * @return {?}
     */
    resetDates(range) {
        this.rangeStoreService.updateRange(range.fromDate, range.toDate);
    }
}
NgxMatDrpComponent.ɵfac = function NgxMatDrpComponent_Factory(t) { return new (t || NgxMatDrpComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(CalendarOverlayService), ɵngcc0.ɵɵdirectiveInject(RangeStoreService), ɵngcc0.ɵɵdirectiveInject(ConfigStoreService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DatePipe)); };
NgxMatDrpComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMatDrpComponent, selectors: [["ngx-mat-drp"]], viewQuery: function NgxMatDrpComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendarInput = _t.first);
    } }, inputs: { options: "options" }, outputs: { selectedDateRangeChanged: "selectedDateRangeChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([
            CalendarOverlayService,
            RangeStoreService,
            ConfigStoreService,
            DatePipe
        ])], decls: 5, vars: 3, consts: [[1, "ngx-mat-drp-date-display"], ["matInput", "", "readonly", "", 1, "ngx-mat-drp-date-input", 3, "placeholder", "value", "matTooltip", "click"], ["calendarInput", ""], ["matSuffix", "", 1, "ngx-mat-drp-calendar", 3, "click"]], template: function NgxMatDrpComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "mat-form-field", 0);
        ɵngcc0.ɵɵelementStart(2, "input", 1, 2);
        ɵngcc0.ɵɵlistener("click", function NgxMatDrpComponent_Template_input_click_2_listener($event) { return ctx.openCalendar($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵlistener("click", function NgxMatDrpComponent_Template_div_click_4_listener($event) { return ctx.openCalendar($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("placeholder", ctx.options.placeholder)("value", ctx.selectedDateRange)("matTooltip", ctx.selectedDateRange);
    } }, directives: [ɵngcc4.MatFormField, ɵngcc5.MatInput, ɵngcc6.MatTooltip, ɵngcc4.MatSuffix], styles: [".ngx-mat-drp-date-display[_ngcontent-%COMP%]{min-width:230px}.ngx-mat-drp-date-input[_ngcontent-%COMP%]{text-overflow:ellipsis;color:#4169e1}.ngx-mat-drp-calendar[_ngcontent-%COMP%]{background-image:url('data:image/svg+xml,<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">    <path d=\"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z\"/>    <path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>');width:24px;height:24px}"], changeDetection: 0 });
/** @nocollapse */
NgxMatDrpComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: CalendarOverlayService },
    { type: RangeStoreService },
    { type: ConfigStoreService },
    { type: DatePipe }
];
NgxMatDrpComponent.propDecorators = {
    calendarInput: [{ type: ViewChild, args: ['calendarInput',] }],
    selectedDateRangeChanged: [{ type: Output }],
    options: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatDrpComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-mat-drp',
                template: `<div> 
  
  <mat-form-field class="ngx-mat-drp-date-display">
    <input class="ngx-mat-drp-date-input"
          matInput [placeholder]="options.placeholder"
          [value]="selectedDateRange"
          [matTooltip]="selectedDateRange"
          (click)="openCalendar($event)"
          readonly
          #calendarInput >
    <div matSuffix 
          class="ngx-mat-drp-calendar"
          (click)="openCalendar($event)">
    </div>
  </mat-form-field>
  
</div>    
`,
                styles: [`.ngx-mat-drp-date-display{min-width:230px}.ngx-mat-drp-date-input{text-overflow:ellipsis;color:#4169e1}.ngx-mat-drp-calendar{background-image:url('data:image/svg+xml,<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">    <path d="M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"/>    <path d="M0 0h24v24H0z" fill="none"/></svg>');width:24px;height:24px}`],
                providers: [
                    CalendarOverlayService,
                    RangeStoreService,
                    ConfigStoreService,
                    DatePipe
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: CalendarOverlayService }, { type: RangeStoreService }, { type: ConfigStoreService }, { type: ɵngcc3.DatePipe }]; }, { selectedDateRangeChanged: [{
            type: Output
        }], calendarInput: [{
            type: ViewChild,
            args: ['calendarInput']
        }], options: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CalendarWrapperComponent {
    /**
     * @param {?} configStore
     */
    constructor(configStore) {
        this.configStore = configStore;
        this.selectedDateChange = new EventEmitter();
        this.weekendFilter = (d) => true;
        this.dateFormat = configStore.ngxDrpOptions.format;
        if (configStore.ngxDrpOptions.excludeWeekends) {
            this.weekendFilter = (d) => {
                /** @type {?} */
                const day = d.getDay();
                return day !== 0 && day !== 6;
            };
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Necessary to force view refresh
        this.matCalendar.activeDate = changes["selectedDate"].currentValue;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    onSelectedChange(date) {
        this.selectedDateChange.emit(date);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onYearSelected(e) { }
    /**
     * @param {?} e
     * @return {?}
     */
    onUserSelection(e) { }
}
CalendarWrapperComponent.ɵfac = function CalendarWrapperComponent_Factory(t) { return new (t || CalendarWrapperComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigStoreService)); };
CalendarWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CalendarWrapperComponent, selectors: [["calendar-wrapper"]], viewQuery: function CalendarWrapperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(MatCalendar, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.matCalendar = _t.first);
    } }, inputs: { selectedDate: "selectedDate", prefixLabel: "prefixLabel", minDate: "minDate", maxDate: "maxDate" }, outputs: { selectedDateChange: "selectedDateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 10, consts: [[1, "ngx-mat-drp-date-label"], [1, "ngx-mat-drp-selected-date-label"], [3, "startAt", "selected", "minDate", "maxDate", "dateFilter", "selectedChange", "yearSelected", "_userSelection"]], template: function CalendarWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "span", 0);
        ɵngcc0.ɵɵelementStart(2, "label");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "label", 1);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵpipe(6, "date");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "mat-calendar", 2);
        ɵngcc0.ɵɵlistener("selectedChange", function CalendarWrapperComponent_Template_mat_calendar_selectedChange_7_listener($event) { return ctx.onSelectedChange($event); })("yearSelected", function CalendarWrapperComponent_Template_mat_calendar_yearSelected_7_listener($event) { return ctx.onYearSelected($event); })("_userSelection", function CalendarWrapperComponent_Template_mat_calendar__userSelection_7_listener($event) { return ctx.onUserSelection($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.prefixLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(6, 7, ctx.selectedDate, ctx.dateFormat));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("startAt", ctx.selectedDate)("selected", ctx.selectedDate)("minDate", ctx.minDate)("maxDate", ctx.maxDate)("dateFilter", ctx.weekendFilter);
    } }, directives: [ɵngcc7.MatCalendar], pipes: [ɵngcc3.DatePipe], styles: [".ngx-mat-drp-date-label[_ngcontent-%COMP%]{background:#fafafa;margin:15px;padding:4px 2px;width:100%;font-size:14px;font-weight:500}.ngx-mat-drp-selected-date-label[_ngcontent-%COMP%]{color:rgba(0,0,0,.38);padding-left:5%}"], changeDetection: 0 });
/** @nocollapse */
CalendarWrapperComponent.ctorParameters = () => [
    { type: ConfigStoreService }
];
CalendarWrapperComponent.propDecorators = {
    matCalendar: [{ type: ViewChild, args: [MatCalendar,] }],
    selectedDateChange: [{ type: Output }],
    selectedDate: [{ type: Input }],
    prefixLabel: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'calendar-wrapper',
                template: `<div>

  <!-- <mat-divider></mat-divider> -->
  <span class="ngx-mat-drp-date-label">
    <label>{{prefixLabel}}</label>
    <label class="ngx-mat-drp-selected-date-label">{{selectedDate | date:dateFormat}}</label>
  </span>
  <!-- <mat-divider></mat-divider> -->

  <mat-calendar 
    [startAt]="selectedDate"
    [selected]="selectedDate"
    [minDate]="minDate"
    [maxDate]="maxDate"
    (selectedChange)="onSelectedChange($event)"
    (yearSelected)="onYearSelected($event)"
    (_userSelection)="onUserSelection($event)"
    [dateFilter]="weekendFilter">
  </mat-calendar>

</div>`,
                styles: [`.ngx-mat-drp-date-label{background:#fafafa;margin:15px;padding:4px 2px;width:100%;font-size:14px;font-weight:500}.ngx-mat-drp-selected-date-label{color:rgba(0,0,0,.38);padding-left:5%}`],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ConfigStoreService }]; }, { selectedDateChange: [{
            type: Output
        }], matCalendar: [{
            type: ViewChild,
            args: [MatCalendar]
        }], selectedDate: [{
            type: Input
        }], prefixLabel: [{
            type: Input
        }], minDate: [{
            type: Input
        }], maxDate: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PresetsComponent {
    constructor() {
        this.presetChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} event
     * @return {?}
     */
    setPresetPeriod(event) {
        this.presetChanged.emit(event);
    }
}
PresetsComponent.ɵfac = function PresetsComponent_Factory(t) { return new (t || PresetsComponent)(); };
PresetsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PresetsComponent, selectors: [["mat-drp-presets"]], inputs: { presets: "presets" }, outputs: { presetChanged: "presetChanged" }, decls: 3, vars: 1, consts: [[1, "ngx-mat-drp-presets-list"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"]], template: function PresetsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "ul", 0);
        ɵngcc0.ɵɵtemplate(2, PresetsComponent_li_2_Template, 2, 1, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.presets);
    } }, directives: [ɵngcc3.NgForOf], styles: [".ngx-mat-drp-presets-list[_ngcontent-%COMP%]{list-style-type:none;margin:0;padding:0}.ngx-mat-drp-presets-list[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{margin:5px 0;padding:4%;cursor:pointer;background:#fafafa;color:#3f51b5;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-drp-presets-list[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover{background:#3f51b5;color:#fff}"], changeDetection: 0 });
/** @nocollapse */
PresetsComponent.ctorParameters = () => [];
PresetsComponent.propDecorators = {
    presets: [{ type: Input }],
    presetChanged: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PresetsComponent, [{
        type: Component,
        args: [{
                selector: 'mat-drp-presets',
                template: `<div>
  <ul class="ngx-mat-drp-presets-list">
    <li *ngFor="let preset of presets" (click)="setPresetPeriod(preset)"> {{preset.presetLabel}} </li>
  </ul>
</div>`,
                styles: [`.ngx-mat-drp-presets-list{list-style-type:none;margin:0;padding:0}.ngx-mat-drp-presets-list li{margin:5px 0;padding:4%;cursor:pointer;background:#fafafa;color:#3f51b5;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-drp-presets-list li:hover{background:#3f51b5;color:#fff}`],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { presetChanged: [{
            type: Output
        }], presets: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
const ɵ0 = new Date();
class NgxMatDrpModule {
}
NgxMatDrpModule.ɵfac = function NgxMatDrpModule_Factory(t) { return new (t || NgxMatDrpModule)(); };
NgxMatDrpModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxMatDrpModule });
NgxMatDrpModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        { provide: DATE, useValue: ɵ0 }
    ], imports: [[
            CommonModule,
            MatFormFieldModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatInputModule,
            MatButtonModule,
            MatTooltipModule,
            OverlayModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMatDrpModule, { declarations: function () { return [NgxMatDrpComponent, CalendarWrapperComponent, PickerOverlayComponent, PresetsComponent]; }, imports: function () { return [CommonModule,
        MatFormFieldModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatInputModule,
        MatButtonModule,
        MatTooltipModule,
        OverlayModule]; }, exports: function () { return [NgxMatDrpComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatDrpModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatFormFieldModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatInputModule,
                    MatButtonModule,
                    MatTooltipModule,
                    OverlayModule
                ],
                declarations: [
                    NgxMatDrpComponent,
                    CalendarWrapperComponent,
                    PickerOverlayComponent,
                    PresetsComponent
                ],
                providers: [
                    { provide: DATE, useValue: ɵ0 }
                ],
                entryComponents: [PickerOverlayComponent],
                exports: [NgxMatDrpComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxMatDrpModule, NgxMatDrpComponent, PickerOverlayComponent, CalendarWrapperComponent, PresetsComponent, CalendarOverlayService, ConfigStoreService, DATE, RangeStoreService, pickerOverlayAnimations as ɵa };

//# sourceMappingURL=ngx-mat-daterange-picker.js.map