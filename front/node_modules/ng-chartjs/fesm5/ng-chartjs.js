import { __decorate, __metadata } from 'tslib';
import { ɵɵdefineInjectable, Injectable, ɵɵinject, EventEmitter, ElementRef, NgZone, Input, Output, Directive, InjectionToken, NgModule } from '@angular/core';
import * as Chart from 'chart.js';
import { plugins } from 'chart.js';

var StoreService = /** @class */ (function () {
    function StoreService() {
        this._chartInstances = [];
        this._chartId = [];
    }
    StoreService.prototype.addChart = function (id, chart) {
        for (var i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                return;
            }
        }
        this._chartId.push(id);
        this._chartInstances.push(chart);
    };
    StoreService.prototype.removeChart = function (id) {
        for (var i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                this._chartId.splice(i, 1);
                this._chartInstances.splice(i, 1); // delete chart instance.
            }
        }
    };
    StoreService.prototype.getChart = function (id) {
        for (var i = 0; i < this._chartId.length; i++) {
            if (id === this._chartId[i]) {
                return this._chartInstances[i];
            }
        }
        return null;
    };
    StoreService.ɵprov = ɵɵdefineInjectable({ factory: function StoreService_Factory() { return new StoreService(); }, token: StoreService, providedIn: "root" });
    StoreService = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], StoreService);
    return StoreService;
}());

var PluginConfig = /** @class */ (function () {
    function PluginConfig() {
        this.plugins = [];
    }
    PluginConfig.ɵprov = ɵɵdefineInjectable({ factory: function PluginConfig_Factory() { return new PluginConfig(); }, token: PluginConfig, providedIn: "root" });
    PluginConfig = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], PluginConfig);
    return PluginConfig;
}());

var NgChartjsService = /** @class */ (function () {
    function NgChartjsService(storeService, pluginConfig) {
        this.storeService = storeService;
        this.pluginConfig = pluginConfig;
        var plugins$1 = pluginConfig.plugins;
        if (plugins$1.length !== 0 || plugins$1) {
            for (var i = 0; i < plugins$1.length; i++) {
                if (plugins$1[i]) {
                    plugins.register(plugins$1[i]);
                }
            }
        }
    }
    // get chart instance by id
    NgChartjsService.prototype.getChart = function (id) {
        return this.storeService.getChart(id);
    };
    NgChartjsService.ctorParameters = function () { return [
        { type: StoreService },
        { type: PluginConfig }
    ]; };
    NgChartjsService.ɵprov = ɵɵdefineInjectable({ factory: function NgChartjsService_Factory() { return new NgChartjsService(ɵɵinject(StoreService), ɵɵinject(PluginConfig)); }, token: NgChartjsService, providedIn: "root" });
    NgChartjsService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [StoreService,
            PluginConfig])
    ], NgChartjsService);
    return NgChartjsService;
}());

// Default colors
var DefaultColors = [
    [63, 81, 181],
    [0, 150, 136],
    [255, 152, 0],
    [233, 30, 99],
    [156, 39, 176],
    [0, 188, 212],
    [3, 169, 244],
    [96, 125, 139],
    [255, 193, 7],
    [37, 155, 36],
    [205, 220, 57],
    [86, 119, 252] // Blue
];
function rgba(colour, alpha) {
    return 'rgba(' + colour.concat(alpha).join(',') + ')';
}
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function formatLineColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.35),
        borderColor: rgba(colors, 1),
        pointBackgroundColor: rgba(colors, 1),
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: rgba(colors, 0.95)
    };
}
function formatBarColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.75),
        borderColor: rgba(colors, 1),
        hoverBackgroundColor: rgba(colors, 1),
        hoverBorderColor: rgba(colors, 1)
    };
}
function formatPieColors(colors) {
    return {
        backgroundColor: colors.map(function (color) { return rgba(color, 0.76); }),
        borderColor: colors.map(function () { return '#fff'; }),
        pointBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
        pointBorderColor: colors.map(function () { return '#fff'; }),
        pointHoverBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
        pointHoverBorderColor: colors.map(function (color) { return rgba(color, 1); })
    };
}
function formatPolarAreaColors(colors) {
    return {
        backgroundColor: colors.map(function (color) { return rgba(color, 0.75); }),
        borderColor: colors.map(function (color) { return rgba(color, 1); }),
        hoverBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
        hoverBorderColor: colors.map(function (color) { return rgba(color, 1); })
    };
}
function getRandomColor() {
    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
}
/**
* @method Generate colors for line|bar charts
* @param index he index of the default color array. eg. 0, 1
* @return number[]
* @author vincent 2019-01-22
* @version 0.0.0
* @example
* @log 1. vincent,2019-01-22,done
*/
function generateColor(index) {
    return DefaultColors[index] || getRandomColor();
}
/**
* @method Generate colors for pie|doughnut charts
* @param count Length of data. eg. datasets.data.length
* @return number[][]
* @author vincent 2019-01-22
* @version 0.0.0
* @example
* @log 1. vincent,2019-01-22,done
*/
function generateColors(count) {
    var colorsArr = new Array(count);
    for (var i = 0; i < count; i++) {
        colorsArr[i] = DefaultColors[i] || getRandomColor();
    }
    return colorsArr;
}
/**
* @method Generate colors by chart type
* @param chartType The type of chart you are using. eg. line,bar
* @param index The index of the default color array. eg. DefaultColors[index]
* @param count Length of data. eg. datasets.data.length
* @return Color or number[]
* @author vincent 2019-01-22
* @version 0.0.0
* @example
* @log 1. vincent,2019-01-22,done
*/
function getColors(chartType, index, count) {
    if (chartType === 'pie' ||
        chartType === 'doughnut' ||
        chartType === 'bubble' ||
        chartType === 'scatter') {
        return formatPieColors(generateColors(count));
    }
    if (chartType === 'polarArea') {
        return formatPolarAreaColors(generateColors(count));
    }
    if (chartType === 'line' || chartType === 'radar') {
        return formatLineColor(generateColor(index));
    }
    if (chartType === 'bar' || chartType === 'horizontalBar') {
        return formatBarColor(generateColor(index));
    }
    return generateColor(index);
}

/* tslint:disable-next-line */
var NgChartjsDirective = /** @class */ (function () {
    function NgChartjsDirective(element, ngChartjsService, storeService, zone) {
        this.ngChartjsService = ngChartjsService;
        this.storeService = storeService;
        this.zone = zone;
        // x轴标签。这对图表来说是必要的：线，条和雷达。并且只是图表的标签（悬停）：polarArea，pie和doughnut
        this.labels = [];
        // 相当于chart.js的option
        this.options = {};
        this.noZone = true; // disable angular NgZone
        this.id = null; // chart instance id
        // 鼠标点击图表所有的区域
        this.chartClick = new EventEmitter();
        // 鼠标悬浮在标签或者活跃的点上面时
        this.chartHover = new EventEmitter();
        this.initFlag = false;
        this.hasChanges = false;
        this.element = element; // 获取指令所在canvas元素
    }
    NgChartjsDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.ctx = this.element.nativeElement.getContext('2d'); // 获取元素的ctx
        this.initFlag = true; // 是否初始化了的标志
        if (this.data || this.datasets) { // 判断data和datasets有一个有数据就刷新
            if (this.noZone) {
                this.zone.runOutsideAngular(function () {
                    _this.refresh();
                });
            }
            else {
                this.refresh();
            }
        }
    };
    NgChartjsDirective.prototype.ngOnChanges = function (changes) {
        // TODO: 插件变化刷新，开放刷新按钮
        if (this.initFlag) {
            // Check if the changes are in the data or datasets
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes.data) {
                    this.updateChartData(changes.data.currentValue);
                }
                else {
                    this.updateChartData(changes.datasets.currentValue);
                }
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('labels')) {
                this.chart.data.labels = changes.labels.currentValue;
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('legend')) {
                if (changes.legend.currentValue !== changes.legend.previousValue) {
                    this.chart.options.legend.display = changes.legend.currentValue;
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('adding')) {
                this.addData_(changes.adding.currentValue.labels, changes.adding.currentValue.data);
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('removing')) {
                if (changes.removing.currentValue.orientation === 'oldest' || changes.removing.currentValue.orientation === 'latest') {
                    this.removeData_(changes.removing.currentValue.orientation);
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('chartType')) {
                this.refresh();
            }
            if (changes.hasOwnProperty('resetOption')) {
                Object.assign(this.chart.options, changes.resetOption.currentValue);
                this.hasChanges = true;
            }
            if (this.hasChanges) {
                this.chart.update();
                this.hasChanges = false;
            }
            // change chart id
            if (changes.hasOwnProperty('id')) {
                this.removeChart(changes.id.previousValue);
                this.addChart(changes.id.currentValue);
            }
        }
    };
    NgChartjsDirective.prototype.ngOnDestroy = function () {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
            this.removeChart(this.id);
        }
    };
    // update chartjs
    NgChartjsDirective.prototype.update = function () {
        this.chart.update();
    };
    // Dynamic add data
    NgChartjsDirective.prototype.addData = function (labels, data) {
        this.addData_(labels, data);
        this.update();
    };
    // Dynamic remove data, orientation is 'ildest' or 'latest'
    NgChartjsDirective.prototype.removeData = function (orientation) {
        this.removeData_(orientation);
        this.update();
    };
    NgChartjsDirective.prototype.refresh = function () {
        this.ngOnDestroy();
        this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
        this.addChart(this.id);
    };
    NgChartjsDirective.prototype.removeChart = function (id) {
        if (this.element.nativeElement.hasAttribute('id')) {
            this.storeService.removeChart(this.element.nativeElement.id);
            return;
        }
        if (id !== null && id !== undefined) {
            this.storeService.removeChart(id); // delete chart instance.
        }
    };
    NgChartjsDirective.prototype.addChart = function (id) {
        if (this.element.nativeElement.hasAttribute('id')) {
            this.storeService.addChart(this.element.nativeElement.id, this.chart);
            return;
        }
        if (id !== null && id !== undefined) {
            this.storeService.addChart(id, this.chart);
        }
    };
    NgChartjsDirective.prototype.updateChartData = function (newDataValues) {
        if (Array.isArray(newDataValues[0].data)) {
            this.chart.data.datasets.forEach(function (dataset, i) {
                dataset.data = newDataValues[i].data;
                if (newDataValues[i].label) {
                    dataset.label = newDataValues[i].label;
                }
            });
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
        // update colors
        this.chart.data.datasets = this.updateColors(this.chart.data.datasets);
    };
    NgChartjsDirective.prototype.getChartBuilder = function (ctx /*, data:Array<any>, options:any*/) {
        var _this = this;
        var datasets = this.getDatasets();
        var options = Object.assign({}, this.options); // 深复制options
        if (this.legend === false) { // 设置options的legend TODO: 后续这个属性去除，直接在options内设置
            options.legend = { display: false };
        }
        // hock for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = function (event, active) {
                if (active && !active.length) {
                    return;
                }
                _this.chartHover.emit({ event: event, active: active });
            };
        }
        if (!options.onClick) {
            options.onClick = function (event, active) {
                _this.chartClick.emit({ event: event, active: active });
            };
        }
        var opts = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets: datasets // TODO: 后续更改这个属性名字，否则警告
            },
            options: options,
            plugins: this.inlinePlugins
        };
        return new Chart(ctx, opts);
    };
    // 获取 chart.js的datasets数据
    NgChartjsDirective.prototype.getDatasets = function () {
        var _this = this;
        var datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (Array.isArray(this.data[0])) {
                datasets = this.data.map(function (data, index) {
                    return { data: data, label: _this.labels[index] || "Label " + index };
                });
            }
            else {
                datasets = [{ data: this.data, label: "Label 0" }];
            }
        }
        datasets = this.updateColors(datasets); // update colors
        if (!datasets) {
            throw new Error("ng-chartjs configuration error,\n      data or datasets field are required to render char " + this.chartType);
        }
        return datasets;
    };
    // update dataset colors
    NgChartjsDirective.prototype.updateColors = function (datasets) {
        var _this = this;
        if (this.datasets && this.datasets.length || (datasets && datasets.length)) {
            // fix elm type, pre type is number
            datasets = (this.datasets || datasets).map(function (elm, index) {
                var newElm = Object.assign({}, elm);
                if (_this.colors && _this.colors.length) {
                    Object.assign(newElm, _this.colors[index]);
                }
                else {
                    Object.assign(newElm, getColors(_this.chartType, index, newElm.data.length));
                }
                return newElm;
            });
        }
        return datasets;
    };
    NgChartjsDirective.prototype.addData_ = function (labels, data) {
        var _this = this;
        if (labels.length === 0 || data.length === 0) {
            return;
        }
        // update labels
        labels.forEach(function (label) { _this.chart.data.labels.push(label); });
        this.chart.data.datasets.forEach(function (dataset, index) {
            if (data[index]) {
                for (var i = 0; i < data[index].length; i++) {
                    dataset.data.push(data[index][i]);
                }
            }
            else {
                console.log('The added data does not match the original data');
                return;
            }
        });
    };
    NgChartjsDirective.prototype.removeData_ = function (orientation) {
        // fix: support to oldest feature
        if (orientation === 'latest') {
            this.chart.data.labels.pop();
            this.chart.data.datasets.forEach(function (dataset) {
                dataset.data.pop();
            });
        }
        else if (orientation === 'oldest') {
            this.chart.data.labels.shift();
            this.chart.data.datasets.forEach(function (dataset) {
                dataset.data.shift();
            });
        }
    };
    NgChartjsDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgChartjsService },
        { type: StoreService },
        { type: NgZone }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NgChartjsDirective.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NgChartjsDirective.prototype, "datasets", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NgChartjsDirective.prototype, "labels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgChartjsDirective.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NgChartjsDirective.prototype, "inlinePlugins", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgChartjsDirective.prototype, "chartType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], NgChartjsDirective.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], NgChartjsDirective.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgChartjsDirective.prototype, "adding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgChartjsDirective.prototype, "removing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgChartjsDirective.prototype, "resetOption", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgChartjsDirective.prototype, "noZone", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgChartjsDirective.prototype, "id", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], NgChartjsDirective.prototype, "chartClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], NgChartjsDirective.prototype, "chartHover", void 0);
    NgChartjsDirective = __decorate([
        Directive({ selector: 'canvas[ngChartjs]', exportAs: 'ngChartjs' }),
        __metadata("design:paramtypes", [ElementRef,
            NgChartjsService,
            StoreService,
            NgZone])
    ], NgChartjsDirective);
    return NgChartjsDirective;
}());

var NgChartjsCustomPluginToken = new InjectionToken('[ngx-chart-js] Global Default Plugin');

function ngChartjsCustomPluginsFactory(plugins) {
    var pluginConfig = new PluginConfig();
    pluginConfig.plugins = plugins;
    return pluginConfig;
}
var NgChartjsModule = /** @class */ (function () {
    function NgChartjsModule() {
    }
    NgChartjsModule_1 = NgChartjsModule;
    /**
     * Register a plugin.
     * @param plugin
     */
    NgChartjsModule.registerPlugin = function (plugins) {
        if (plugins === void 0) { plugins = []; }
        return {
            ngModule: NgChartjsModule_1,
            providers: [
                {
                    provide: NgChartjsCustomPluginToken,
                    useValue: plugins
                },
                {
                    deps: [NgChartjsCustomPluginToken],
                    provide: PluginConfig,
                    useFactory: ngChartjsCustomPluginsFactory
                }
            ]
        };
    };
    var NgChartjsModule_1;
    NgChartjsModule = NgChartjsModule_1 = __decorate([
        NgModule({
            imports: [],
            declarations: [NgChartjsDirective],
            exports: [NgChartjsDirective],
            providers: [NgChartjsService]
        })
    ], NgChartjsModule);
    return NgChartjsModule;
}());

/*
 * Public API Surface of ng-chartjs
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DefaultColors, NgChartjsDirective, NgChartjsModule, NgChartjsService, formatBarColor, formatLineColor, formatPieColors, formatPolarAreaColors, generateColor, generateColors, getColors, getRandomColor, getRandomInt, ngChartjsCustomPluginsFactory, rgba, StoreService as ɵa, PluginConfig as ɵb, NgChartjsCustomPluginToken as ɵc };
//# sourceMappingURL=ng-chartjs.js.map
